#挑战简介
#这题我可得注重讲一讲，卡了我有一个星期
#此题要求：
*给你一个程序，主界面两个选择
1.输入明文并用一个随机密钥给你加密展示(随机密钥在一次执行中固定唯一)
2.输入一个index索引和长度，对flag的一部分进行加密展示
*密钥未知，flag未知
#这边对于AES-ECB有个概念：
对于块大小的字节，加密的字节数如小于块大小，那么密文大小固定；
如果大于等于块大小，那么密文大小则会再加上一个块大小(乱总结的)
#这个不重要，重要的是这题的思路
#思路：创建一个flag范围字符的字典，将所有字符的加密密文储存起来，对flag进行逐个字节的对照，从而推出明文

#思路有了，但是人工计算成本巨大，每个字符的加密与对照，58字节的flag，对照次数要达数百次，费时费力
#因此我们要会用python得一个库函数
*pwntools

#代码如下：
*我将解释每一段代码，都是我花费了超长时间学到的
#!/usr/bin/python
from pwn import *  //引入pwntools

d = []        开辟一个数组，用于存放字典，包括字符和加密密文
valid_ascii = (
    list(range(48, 58))+      //0~9
    list(range(65, 91))+        //A~Z
    list(range(97, 123))+         //a~z
    [45, 46, 95, 173, 175]          //特殊字符
)
#d[valid_ascii[0]] = chr(valid_ascii[0])      
#print(d[valid_ascii[0]])
context(os='linux',arch='AMD64',log_level='debug')

p = process('/challenge/run')

def encryascii(number):
    for i in range(number):
        p.recvline(b'Choice?')
        p.sendline(b'1')
        p.recvuntil(b'Data?')
        p.sendline(chr(valid_ascii[i]))
        p.recvuntil(b'Result:')
        data=p.recvline().strip()
        d.append((chr(valid_ascii[i]),data))
        if chr(valid_ascii[i]) == '_':
            break

def encrypt_flag_char(index,length):
    p.recvline(b'Choice?')
    p.sendline(b'2')
    p.recvline(b'Index?')
    p.sendline(str(index).encode())
    p.recvuntil(b'Length?')
    p.sendline(str(length).encode())
    p.recvuntil(b'Result:')
    return p.recvline().strip()

encryascii(len(valid_ascii))

flag = ''
for idx in range(58):
    encry_char = encrypt_flag_char(idx, 1)
    for char, enc_data in d:
        if enc_data == encry_char:
            flag += char
            print(f"Found character {char} at index {idx}")
            break

#for idx, data in enumerate(d):
    #print(f"Result for {chr(valid_ascii[idx])}: {data.decode()}")
print(f"the flag {flag}")
