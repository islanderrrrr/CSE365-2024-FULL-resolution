# 挑战简介
你是否更喜欢访问地址133700还是123400？这个问题可能反映出你的性格，但从技术角度来看并不重要。实际上，在编写程序时，大多数情况下你并不直接处理实际的内存地址。  

这怎么可能呢？通常情况下，内存地址存储在寄存器中，我们使用寄存器中的值来指向内存中的数据。让我们来看这个内存配置：  

diff  
  地址 │ 内容  
+────────────────────+  
│ 133700  │ 42       │  
+────────────────────+  
考虑以下汇编代码片段：  

assembly  
mov rdi, 133700  
此时的情况是：  
diff  
  地址 │ 内容  
+────────────────────+  
│ 133700  │ 42       │◂┐  
+────────────────────+ │  
                       │  
 寄存器 │ 内容       │  
+────────────────────+ │  
│ rdi     │ 133700   │─┘  
+────────────────────+  
rdi现在持有一个与我们要加载的数据的地址对应的值！接下来，让我们加载它：  

assembly  
mov rdi, [rax]  
在这里，我们访问内存，但并没有直接指定一个固定地址（如133700），而是使用rax中存储的值作为内存地址。因为rax包含内存地址，所以它是一个指向我们想要访问的数据的指针。当我们使用rax代替直接指定的地址来访问它所引用的内存地址时，我们称之为解引用指针。在上面的示例中，我们解引用rax，将它指向的数据（地址133700处的值42）加载到rdi中。很酷吧！

这也强调了一个观点：这些寄存器是通用的！虽然到目前为止我们使用rax作为系统调用索引，但它也可以用于其他用途。在这里，它作为指向内存中秘密数据的指针。

同样，寄存器中的数据并没有隐含的用途。如果rax中包含值133700，而我们执行mov rdi, [rax]，CPU会将该值用作内存地址进行解引用。但如果我们写mov rdi, rax，CPU就会将133700放入rdi。在CPU看来，数据就是数据；它的用途取决于如何使用。

在这个挑战中，我们已将rax初始化为存储秘密数据的地址。请解引用rax，将秘密数据加载到rdi中，并将其用作程序的退出码以获取标志！

# 思路很简单:
rax储存了一个地址，将rax的值作为rdi的地址，从而使rdi得到这个地址的值，即可
```
mov rdi, [rax]  
mov rax, 60  
syscall
```
