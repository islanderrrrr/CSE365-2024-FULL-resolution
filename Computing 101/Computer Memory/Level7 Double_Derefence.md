# 挑战简介
在前几关中，你已经：

使用给定的地址（如133700和123400）从内存加载秘密值。  
使用存储在rax中的地址从内存加载秘密值。  
使用给定的地址（在最后一关中是567800）将秘密值的地址加载到寄存器中，然后用该寄存器作为指针从内存中检索秘密值。  
现在，让我们将这两者结合起来。在这个挑战中，我们将SECRET_VALUE存储在地址SECRET_LOCATION_1中，然后将SECRET_LOCATION_1存储在地址SECRET_LOCATION_2中。接着，我们将SECRET_ADDRESS_2放入rax中！结果大致如下（实际挑战中这些值会不同并且隐藏）：  

markdown  
     地址 │ 内容  
   +────────────────────+  
 ┌─│ 133700  │ 123400   │◂┐  
 │ +────────────────────+ │  
 └▸│ 123400  │ 42       │ │  
   +────────────────────+ │  
                          │  
                          │  
                          │  
    寄存器 │ 内容       │  
   +────────────────────+ │  
   │ rdi     │ 133700   │─┘  
   +────────────────────+  
在这里，你需要执行两次内存读取：第一次解引用rax，从rax指向的位置读取SECRET_LOCATION_1；第二次解引用当前存储SECRET_LOCATION_1的寄存器，以将SECRET_VALUE读取到rdi中，这样你就可以将其用作退出码。  

虽然听起来有些复杂，但你已经做过类似的事情。现在，去将它们组合起来吧！

# 思路:
依旧是地址的套娃，一共三层地址，rax最外层，value2第二层，value1第一层，做就是了
```
mov rdi, [rax]
mov rdi, [rdi]
mov rax, 60
syscall
```
