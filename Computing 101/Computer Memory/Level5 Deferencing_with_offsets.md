# 挑战简介
现在你已经可以像专家一样解引用内存中的指针了！但指针并不总是直接指向你需要的数据。有时，例如，一个指针可能指向一组数据（比如一本书），而你需要引用这组数据中的一部分。

例如，如果你的指针（假设是rdi）指向内存中的一系列数字，如下所示：

diff  
  地址 │ 内容  
+────────────────────+  
│ 133700  │ 50       │◂┐  
│ 133701  │ 42       │ │  
│ 133702  │ 99       │ │  
│ 133703  │ 14       │ │  
+────────────────────+ │  
                       │  
 寄存器 │ 内容       │  
+────────────────────+ │  
│ rdi     │ 133700   │─┘  
+────────────────────+  
如果你想要这一序列中的第二个数字，可以执行：  
```
assembly   
mov rax, [rdi + 1]
```
哇，真简单！在内存中，我们称这些数字位置为字节：每个内存地址代表一个特定的字节。上面的例子访问的是在rdi指向的内存地址之后1个字节的内容。在内存中，我们称这个1字节的差值为偏移量，因此在这个例子中，从rdi指向的地址起有一个偏移量为1。  

现在让我们来练习这个概念。与之前一样，我们将初始化rdi指向秘密值，但这次不是直接指向它。此时，秘密值将位于rdi指向的位置的8字节偏移处，如下所示：  

diff  
  地址 │ 内容  
+────────────────────+  
│ 31337   │ 0        │◂┐  
│ 31337+1 │ 0        │ │  
│ 31337+2 │ 0        │ │  
│ 31337+3 │ 0        │ │  
│ 31337+4 │ 0        │ │  
│ 31337+5 │ 0        │ │  
│ 31337+6 │ 0        │ │  
│ 31337+7 │ 0        │ │  
│ 31337+8 │ ???      │ │  
+────────────────────+ │  
                       │  
 寄存器 │ 内容       │  
+────────────────────+ │  
│ rdi     │ 31337    │─┘  
+────────────────────+   
当然，实际的内存地址不是31337。我们会随机选择一个，并将其存储在rdi中。请使用偏移量8解引用rdi，并获取标志！  
 # 思路:
地址偏移量，既相对于这个数，偏移的大小，如+8就是[现地址+8]  
```
mov rdi, [rdi+8]
mov rax, 60
syscall
```
