# 挑战简介
所以，您的第一个程序崩溃了……别担心，这是会发生的！在这个挑战中，您将学习如何让您的程序干净地退出而不是崩溃。

启动您的程序并干净地停止它是计算机操作系统处理的操作。操作系统管理程序的存在以及程序、硬件、网络环境等之间的交互。

您的程序使用汇编指令（例如您之前编写的 mov 指令）与 CPU“交互”。同样，您的程序使用 syscall 或系统调用指令与操作系统交互（当然是通过 CPU）。

就像您可能使用电话与当地餐馆互动以订购食物一样，程序使用系统调用来请求操作系统代表程序执行操作。作为一种过度概括，您的程序所做的任何不涉及对数据执行计算的操作都是通过系统调用完成的。

您的程序可以调用许多不同的系统调用。例如，Linux 有大约 330 个不同的系统调用，但随着系统调用的增加和弃用，这个数字会随着时间的推移而变化。每个系统调用都由一个系统调用号表示，从 0 开始向上计数，您的程序通过将其系统调用号移动到 rax 寄存器并调用系统调用指令来调用特定的系统调用。例如，如果我们想调用系统调用 42（您稍后会了解的系统调用！），我们会写两条指令：
```
mov rax, 42
syscall
``` 
非常酷，而且超级简单！

在这个挑战中，我们将学习第一个系统调用：exit。exit 系统调用会导致程序退出。通过明确退出，我们可以避免上一个程序遇到的崩溃！

现在，exit 的系统调用号是 60。去写你的第一个程序吧：它应该将 60 移动到 rax，然后调用系统调用以干净地退出！

# 思路:
加入syscall以进行系统调用，
对rax传参60，就是exit，
系统调用完成执行退出即可
