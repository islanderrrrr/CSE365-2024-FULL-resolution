# 挑战简介
让我们学习如何写入文本！

不出所料，你的程序通过调用系统调用来将文本输出到屏幕上。具体来说，这就是写入（write）系统调用，其系统调用编号是1。不过，write系统调用还需要通过其参数指定要写入的数据和写入的位置。  

你可能还记得在Linux Luminarium dojo的管道实践模块中提到的文件描述符（FD）的概念。再提醒一下，每个进程一开始都有三个文件描述符：

FD 0：标准输入，是进程接收输入的通道。例如，你的shell使用标准输入来读取你输入的命令。  
FD 1：标准输出，是进程输出正常数据的通道，比如在之前的挑战中打印给你的标志或像ls这样的工具的输出。  
FD 2：标准错误，是进程输出错误详细信息的通道。例如，如果你输入了错误的命令，shell会通过标准错误输出该命令不存在的消息。  
在write系统调用中，你可以通过第一个参数来指定写入的位置。如果你想写入标准输出，你会将rdi设置为1；如果你想写入标准错误，则将rdi设置为2。非常简单！  

那么，接下来要写什么呢？你可以想象，如果我们通过另一个寄存器参数来指定写入内容，那么这个方法对于写出像这个挑战描述这样长的故事就不太现实了，因为你需要多次调用write系统调用。这样做的性能开销相对较大——CPU需要从执行你程序的指令切换到执行Linux的指令，进行大量的后续计算，与硬件交互以获取实际要显示在屏幕上的像素，然后再切换回来。这很慢，因此我们尝试减少系统调用的次数。  
  
当然，解决这个问题的方法是同时写入多个字符。write系统调用通过接受两个参数来实现这一点：一个是写入的起始内存地址，另一个是要写入的字符数量。这些参数作为write的第二和第三个参数传递。用类似C语言的语法来说，这可以表示为：  
```
c
write(file_descriptor, memory_address, number_of_characters_to_write);
```
举个具体的例子，如果你想从内存地址1337000写入10个字符到标准输出（文件描述符1），你可以这样写：
```
c
write(1, 1337000, 10);
```
太简单了！那么，我们如何实际指定这些参数呢？  

我们将系统调用的第一个参数放在rdi寄存器中。  
将第二个参数通过rsi寄存器传递。在Linux中，约定使用rsi作为系统调用的第二个参数。  
将第三个参数通过rdx寄存器传递。这里是本模块中最令人困惑的部分：rdi（存放第一个参数的寄存器）与rdx的名字如此相似，容易混淆，不幸的是，这种命名是出于历史原因而存在的，且没有改变的可能。没关系... 只需小心对待这个问题。可以用类似“rdi是初始参数，而rdx是额外参数”的记忆法来帮助记忆；或者想象成需要跟踪不同名字相似的朋友，这样你就能应对自如了。  
当然，写入系统调用的索引会存放在rax中：1。除了rdi和rdx的混淆，这个过程其实非常简单！  

和之前一样，我们将在地址1337000中写入一个秘密字符值。现在调用write将这个单字符值写入标准输出，我们会给你标志！  

# 思路:
引入了3个新的参数意义:
- **rdi**:系统调用编号，系统参数
- **rsi**:地址
- **rdx**:数据长度，额外参数  
如下:
```
mov rax, 1
mov rdx, 1
mov rsi, 1337000
mov rdi, 1
syscall
```
