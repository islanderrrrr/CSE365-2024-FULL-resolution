# 挑战简介
在这一关中，你将进行寄存器的操作。你需要修改或读取寄存器。

我们将在每次运行之前动态设置一些内存值，每次运行时这些值都会变化。这意味着你需要对寄存器执行某种公式运算。我们会告诉你哪些寄存器被设置，以及结果应该放在哪里，通常是 rax。

在 x86 中，除法比普通数学更特殊。这里的数学称为整数数学，这意味着每个值都是一个整数。

例如：10 / 3 = 3 在整数数学中。

为什么？

因为 3.33 被向下取整为整数。

本关相关的指令是：
```
css
mov rax, reg1
div reg2
```
注意：div 是一条特殊指令，可以将一个 128 位的被除数除以一个 64 位的除数，并使用一个寄存器作为操作数，同时存储商和余数。

这条复杂的 div 指令如何在 128 位的被除数上工作？

对于指令 div reg，会发生以下情况：
```
makefile
rax = rdx:rax / reg
rdx = remainder
```
rdx:rax 表示 rdx 将是 128 位被除数的高 64 位，rax 将是低 64 位。

在调用 div 之前，你必须小心 rdx 和 rax 中的值。

请计算以下内容：

speed = distance/time

其中：

distance = rdi  
time = rsi  
speed = rax  
注意，distance 的值最多是 64 位，因此在除法时 rdx 应该为 0。  

# 思路
**除法思路还是有点复杂，我会对着代码逐条分析**
**步骤如下**  
1. **清空rdx:** 在进行除法运算之前，确保 rdx 为 0，因为我们将进行 64 位的除法。
2. **将 distance 复制到 rax:** 将 rdi 中的距离值移动到 rax 中，这样我们就可以使用它作为被除数。
3. **执行除法:** 使用 div 指令将 rax 除以 rsi 中的时间值。商会存储在 rax 中，余数将存储在 rdx 中。  
**代码如下:**
```
mov rdx, 0            ; 清空 rdx
mov rax, rdi          ; 将 distance 复制到 rax
div rsi               ; 执行除法，rax = distance / time
```
