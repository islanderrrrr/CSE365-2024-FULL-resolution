# 挑战简介
现在，我们将在每次运行之前动态地在内存中设置一些值。每次运行时，这些值都会发生变化。这意味着您需要对寄存器进行某种公式运算。我们会告诉您哪些寄存器是预先设置的，以及您应该将结果放在哪里。在大多数情况下，它是 rax。

在这个级别，您将使用内存。这将要求您读取或写入线性存储在内存中的内容。如果您感到困惑，请查看 'ike 中的线性寻址模块。您可能还会被要求多次取消引用我们动态放入内存中供您使用的内容。

值得注意的是，您可能已经注意到，值的存储顺序与我们表示它们的顺序相反。

举个例子，比如：

[0x1330] = 0x00000000deadc0de  
如果你检查它在内存中实际的样子，你会看到：

[0x1330] = 0xde  
[0x1331] = 0xc0  
[0x1332] = 0xad  
[0x1333] = 0xde  
[0x1334] = 0x00  
[0x1335] = 0x00  
[0x1336] = 0x00  
[0x1337] = 0x00  
这种以“反向”方式存储内容的格式在 x86 中是故意的，它被称为“小端序”。

对于这个挑战，我们将在每次运行时为你提供两个动态创建的地址。

第一个地址将放在 rdi 中。第二个地址将放在 rsi 中。

使用前面提到的信息，执行以下操作：

设置 [rdi] = 0xdeadbeef00001337  
设置 [rsi] = 0xc0ffee0000  
提示：将大常数分配给解除引用的寄存器可能需要一些技巧。尝试将寄存器设置为常数值，然后将该寄存器分配给解除引用的寄存器。

# 思路
将rax作为中间值，来给rdi，rsi赋值，多的我不会了
```
section .text
    global _start

_start:
    mov rax, 0xdeadbeef00001337
    mov [rdi], rax
    mov rax, 0xc0ffee0000
    mov [rsi], rax
```
