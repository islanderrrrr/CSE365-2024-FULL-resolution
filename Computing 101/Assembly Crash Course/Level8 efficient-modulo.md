# 挑战简介
在这个级别中，您将使用寄存器。您将被要求修改或读取寄存器。

我们将在每次运行之前动态地在内存中设置一些值。在每次运行时，这些值都会发生变化。这意味着您需要对寄存器执行某种类型的公式运算。我们会告诉您哪些寄存器是预先设置的，以及您应该将结果放在哪里。在大多数情况下，它是 rax。

事实证明，使用 div 运算符计算模运算很慢！

我们可以使用数学技巧来优化模运算符 (%)。编译器经常使用这个技巧。

如果我们有 x % y，并且 y 是 2 的幂，例如 2^n，则结果将是 x 的低 n 位。

因此，我们可以使用低位寄存器字节访问来有效地实现模数！

仅使用以下指令：

mov  
请计算以下内容：

rax = rdi % 256  
rbx = rsi % 65536  

# 思路
这边提出了一个算模数的绝佳方法，利用低位寄存器访问来实现  
只要了解了每个寄存器低位的分布情况，问题便迎刃而解了  
```
section .text
    global _start

_start:
    mov al, dil
    mov bx, si
```
