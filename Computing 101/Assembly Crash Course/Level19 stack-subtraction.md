# 挑战简介
现在，我们将在每次运行之前动态地在内存中设置一些值。每次运行时，这些值都会发生变化。这意味着您需要对寄存器进行某种类型的公式运算。我们会告诉您哪些寄存器是预先设置的，以及您应该将结果放在哪里。在大多数情况下，它是 rax。

在这一级别中，您将使用堆栈，即动态扩展和收缩的内存区域。您将需要读取和写入堆栈，这可能需要您使用弹出和推送指令。您可能还需要使用堆栈指针寄存器 (rsp) 来了解堆栈指向的位置。

在这些级别中，我们将介绍堆栈。

堆栈是可以存储值以供以后使用的内存区域。

要将值存储在堆栈上，我们使用推送指令，要检索值，我们使用弹出指令。

堆栈是后进先出 (LIFO) 内存结构，这意味着最后推送的值是第一个弹出的值。

想象一下从洗碗机中卸下盘子。假设有 1 个红色、1 个绿色和 1 个蓝色。首先，我们将红色盘子放入柜子中，然后将绿色盘子放在红色盘子上面，然后是蓝色盘子。

我们的盘子堆看起来如下：

顶部 ----> 蓝色  
绿色  
底部 -> 红色  
现在，如果我们想要一个盘子来做三明治，我们会从堆栈中取出顶部盘子，也就是最后放入柜子的蓝色盘子，因此第一个取出。

在 x86 上，pop 指令将从堆栈顶部获取值并将其放入寄存器中。

类似地，push 指令将从寄存器中获取值并将其推送到堆栈顶部。

使用这些指令，获取堆栈顶部的值，从中减去 rdi，然后将其放回。

# 思路
这里正式进入栈内容，介绍了两个语法
1. pop: 弹出栈顶值
2. push: 推入值于栈顶

代码如下:
```
section .text
    global _start

_start:
    pop rax
    sub rax, rdi
    push rax
```

**无需多言**
