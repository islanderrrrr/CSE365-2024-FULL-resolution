# 挑战简介
现在，我们将在每次运行之前动态地在内存中设置一些值。每次运行时，这些值都会改变。这意味着您需要对寄存器进行某种类型的公式运算。我们会告诉您哪些寄存器是预先设置的，以及您应该将结果放在哪里。在大多数情况下，它是 rax。

在这个级别，您将使用内存。这将要求您读取或写入线性存储在内存中的内容。如果您感到困惑，请查看 'ike 中的线性寻址模块。您可能还会被要求多次取消引用我们动态放入内存中供您使用的内容。

到目前为止，您已经使用寄存器作为存储事物的唯一方式，本质上是数学中的变量，例如“x”。

但是，我们也可以将字节存储到内存中！

回想一下，内存可以被寻址，每个地址都包含该位置的内容。请注意，这类似于现实生活中的地址！

举个例子：真实地址“699 S Mill Ave, Tempe, AZ 85281”映射到“ASU Brickyard”。我们也可以称它指向“ASU Brickyard”。我们可以这样表示：

['699 S Mill Ave, Tempe, AZ 85281'] = 'ASU Brickyard'  
该地址很特殊，因为它是独一无二的。但这并不意味着其他地址不能指向同一个东西（因为一个人可以有多栋房子）。  

内存完全一样！

例如，存储代码的内存地址（当我们从您那里获取代码时）是 0x400000。

在 x86 中，我们可以访问内存位置上的内容，这称为解除引用，如下所示：

mov rax, [some_address] <=> 将“some_address”处的内容移动到 rax  
这也适用于寄存器中的内容：

mov rax, [rdi] <=> 将存储在 rdi 所含地址中的内容移动到 rax  
这对于写入内存也同样适用：

mov [rax], rdi <=> 将 rdi 移动到 rax 所含地址。  
因此，如果 rax 为 0xdeadbeef，则 rdi 将存储在地址 0xdeadbeef 中：

[0xdeadbeef] = rdi  
注意：内存是线性的，在 x86_64 中，它从 0 变为 0xffffffffffffffff（是的，非常大）。

请执行以下操作：将存储在 0x404000 的值放入 rax。确保 rax 中的值是存储在 0x404000 的原始值。

# 思路
越学越回去了，之前的"Computer Memory"的学习了相关的**Memory**知识，不多阐述
```
section .text
    global _start

_start:
    mov rax, [0x404000]
```
