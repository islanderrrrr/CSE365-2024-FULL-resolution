# 挑战简介
现在，我们将在每次运行之前动态地在内存中设置一些值。每次运行时，这些值都会发生变化。这意味着您需要对寄存器执行某种类型的公式运算。我们会告诉您哪些寄存器是预先设置的，以及您应该将结果放在哪里。在大多数情况下，它是 rax。

在这个级别，您将使用内存。这将要求您读取或写入线性存储在内存中的内容。如果您感到困惑，请查看 'ike 中的线性寻址模块。您可能还会被要求多次取消引用我们动态放入内存中供您使用的内容。

回想一下，内存是线性存储的。

这是什么意思？

假设我们访问 0x1337 处的四字：

[0x1337] = 0x00000000deadbeef  
内存的实际布局方式是逐字节、小端：

[0x1337] = 0xef  
[0x1337 + 1] = 0xbe  
[0x1337 + 2] = 0xad  
...  
[0x1337 + 7] = 0x00  
这对我们有什么作用？

嗯，这意味着我们可以使用偏移量访问彼此相邻的东西，类似于上面显示的内容。

假设您想要某个地址的第 5 个字节，您可以像这样访问它：

mov al, [address+4]  
请记住，偏移量从 0 开始。

执行以下操作：

从存储在 rdi 中的地址加载两个连续的四字。  
计算前面步骤的四字之和。  
将总和存储在 rsi 中的地址中。

# 思路
偏移量这个概念不多说了，4字就是8字节的偏移量
将[rdi]和[rdi+8]的数据相加存储，就是答案
```
section .text
    global _start

_start:
    mov rax, [rdi]
    mov rbx, [rdi+8]
    add rax, rbx
    mov [rsi], rax
```
