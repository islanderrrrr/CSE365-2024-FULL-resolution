# 挑战简介
在这个级别中，您将使用寄存器。您将被要求修改或读取寄存器。

我们将在每次运行之前动态地在内存中设置一些值。每次运行时，这些值都会改变。这意味着您需要对寄存器执行某种类型的公式运算。我们会告诉您哪些寄存器是预先设置的，以及您应该将结果放在哪里。在大多数情况下，它是 rax。

在这个级别中，您将使用位逻辑和操作。这将涉及大量直接与存储在寄存器或内存位置中的位交互。您还可能需要使用 x86 中的逻辑指令：and、or、not、xor。

在汇编中移动位是另一个有趣的概念！

x86 允许您在寄存器中“移动”位。

以 al 为例，它是 rax 的最低 8 位。

al 中的值（以位为单位）为：

rax = 10001010  
如果我们使用 shl 指令向左移动一次：

shl al, 1  
新值为：  

al = 00010100  
所有内容都向左移动，最高位掉落，而右侧添加了新的 0。  

您可以使用它对您关心的位执行特殊操作。

移位具有快速乘法（乘以 2）或除法（乘以 2）的良好副作用，也可用于计算模数。

以下是重要指令：

shl reg1, reg2 <=> 将 reg1 向左移动 reg2 中的数量  
shr reg1, reg2 <=> 将 reg1 向右移动 reg2 中的数量  
注意：'reg2' 可以用常数或内存位置替换。  

仅使用以下指令：

mov、shr、shl  
请执行以下操作：将 rax 设置为 rdi 的第 5 个最低有效字节。

例如：

rdi = | B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |   
将 rax 设置为 B4 的值

# 思路
这题有些抽象，主讲的是位运算，两个语法:
1. shr, num 位向右移夺少位
```
mov rax, 0b10001010  ; Binary representation of a number
shr rax, 1           ; Shift right by 1 bit
; Result: rax = 0b01000101
```
2. shl, num 位向左移多少位
```
mov rax, 0b10001010  ; Binary representation of a number
shl rax, 1           ; Shift left by 1 bit
; Result: rax = 0b00010100
```
由于这道题不准用and,本该是答案的反倒**不管用**
```
mov rax, rdi       ; 将 rdi 的值复制到 rax 中
shr rax, 32        ; 右移 32 位，使 B4 成为最低有效字节
and rax, 0xFF      ; 用掩码清除其余高位，确保仅保留 B4
```

所以我们要考虑使用其余的办法:套娃
```
mov rax, rdi
```
将 rdi 的值复制到 rax 中。此时，rax 也包含 rdi 的所有 64 位数据。
```
shr rax, 32
```
将 rax 右移 32 位。这一步将 B4 移到最低有效字节（LSB）的位置。此时，rax 中的内容变为：  
```
| B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |  
↓
| 0 | 0 | 0 | B4 | B3 | B2 | B1 | B0 |
```
```
shl rax, 56
```
将 rax 左移 56 位。虽然这里是为了清除其他位，实际情况下，如果要清除其他位可以直接不执行此操作。这里也可以用于进一步保证我们只保留 LSB。  
此时，rax 中只剩下 B4 的值在最左边的位置，剩余位都被填充为 0。  
```
shr rax, 56
```
最后，再将 rax 右移 56 位，这样 B4 就再次移到最低有效字节的位置，准备好用于后续操作。  
结果是 rax 中仅包含 B4 的值。  
