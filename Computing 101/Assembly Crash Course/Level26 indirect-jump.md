# 挑战简介
在这一关中，您将使用控制流操作。这涉及使用指令间接和直接控制特殊寄存器 rip，即指令指针。您将使用 jmp、call、cmp 等指令及其替代指令来实现所请求的行为。

我们将在这一关中使用动态值多次测试您的代码！这意味着我们将以各种随机方式运行您的代码，以验证逻辑是否足够强大，可以正常使用。

最后一种跳转类型是间接跳转，通常用于现实世界中的 switch 语句。Switch 语句是 if 语句的一种特殊情况，它仅使用数字来确定控制流将流向何处。

以下是一个例子：
```
switch(number):
0: jmp do_thing_0
1: jmp do_thing_1
2: jmp do_thing_2
default: jmp do_default_thing
```
本例中的 switch 适用于 number，可以是 0、1 或 2。如果 number 不是这些数字之一，则触发默认。您可以将其视为简化的 else-if 类型结构。在 x86 中，您已经习惯使用数字，因此您可以根据某个东西是确切的数字来创建 if 语句，这不足为奇。此外，如果您知道数字的范围，switch 语句会非常有效。

以跳转表为例。跳转表是内存中连续的部分，用于保存要跳转的位置的地址。

在上面的例子中，跳转表可能如下所示：
```
[0x1337] = do_thing_0 的地址
[0x1337+0x8] = do_thing_1 的地址
[0x1337+0x10] = do_thing_2 的地址
[0x1337+0x18] = do_default_thing 的地址
```
使用跳转表，我们可以大大减少使用的 cmps 数量。现在我们需要检查的是数字是否大于 2。如果是，则始终执行：

jmp [0x1337+0x18]
否则：

jmp [jump_table_address + number * 8]
使用上述知识，实现以下逻辑：
```
如果 rdi 为 0：
jmp 0x40301e
否则如果 rdi 为 1：
jmp 0x4030da
否则如果 rdi 为 2：
jmp 0x4031d5
否则如果 rdi 为 3：
jmp 0x403268
否则：
jmp 0x40332c
请在以下约束下执行上述操作：
```

- 假设 rdi 不会为负数。
-使用不超过 1 个 cmp 指令。
-使用不超过 3 个跳转（任何变体）。
-我们将为您提供在 rdi 中“打开”的数字。
-我们将为您提供 rsi 中的跳转表基址。
这是一个示例表：
```
[0x40427c] = 0x40301e（地址将更改）
[0x404284] = 0x4030da
[0x40428c] = 0x4031d5
[0x404294] = 0x403268
[0x40429c] = 0x40332c
```

# 思路
## 重要信息
**地址的存储是来连续的，16进制的计算规则**  
rsi是基础地址，随着给出的rdi的数，偏移8*rdi的字节  

```
section .text
    global _start

_start:
    cmp rdi, 3            ; 比较 rdi 和 3
    jg default_jump       ; 如果 rdi > 3，跳转到 default_jump

    ; 使用跳转表进行跳转
    shl rdi, 3            ; 将 rdi 左移 3 位（相当于乘以 8，因为每个地址占 8 字节）
    add rdi, rsi          ; 计算跳转地址：jump_table_address + rdi
    jmp [rdi]             ; 跳转到跳转表中指定的地址

default_jump:
    jmp [rsi + 0x20]      ; 跳转到默认地址（假设是 +0x20）
```
