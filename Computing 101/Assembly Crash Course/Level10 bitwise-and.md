# 挑战简介
在本关卡中，您将操作寄存器，并使用位操作。

我们会在每次运行前动态设置内存中的某些值，并要求您对寄存器执行公式化的操作。我们会预先指定哪些寄存器设置了值，并指示您将结果放入哪个寄存器（通常是 rax）。

位逻辑操作是一种有趣的概念，x86 允许逐位对寄存器执行逻辑操作。例如，如果 rax 和 rbx 分别存储以下 8 位值：
```
makefile
rax = 10101010
rbx = 00110011
```
对它们进行按位与（and rax, rbx）操作，会对每一位进行与运算，结果为：
```
makefile
rax = 00100010
```
运算规则：

AND：只有当两个位都是1时，结果才为1。  
OR：只要有一个位为1，结果就为1。  
XOR：当两位不同时，结果为1。  
任务： 请勿使用 mov 或 xchg 指令，将 rax 设置为 rdi AND rsi 的结果。  

# 思路
如题，and的些许聪明用法  
这就不得不谈一谈异或(XOR)的奇妙用法了  
**异或用作交换值**:
```
xor a, b
xor b, a
xor a, b
#此时。a和b交换了位置，自己模拟运算一下，就豁然开朗了
```
明白了交换值，一切都好说了
代码如下:
```
section .text
    global _start

_start:
    xor rax, rdi
    xor rdi, rax
    xor rax, rdi
    and rax, rsi
```
