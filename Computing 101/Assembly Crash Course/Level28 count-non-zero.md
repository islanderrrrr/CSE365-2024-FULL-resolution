# 挑战简介
在这一级别中，您将使用控制流操作。这涉及使用指令间接和直接控制特殊寄存器 rip，即指令指针。您将使用 jmp、call、cmp 等指令及其替代指令来实现所请求的行为。

我们将在这一级别使用动态值多次测试您的代码！这意味着我们将以各种随机方式运行您的代码，以验证逻辑是否足够强大，可以承受正常使用。

在之前的级别中，您发现 for 循环可以迭代多次，无论是动态的还是静态的，但是当您想迭代直到满足条件时会发生什么？

存在第二个循环结构，称为 while 循环，以满足此需求。在 while 循环中，您将迭代直到满足条件。

举个例子，假设我们在内存中有一个位置有相邻的数字，我们想要得到所有数字的平均值，直到找到一个大于或等于 0xff 的数字：
```
average = 0
i = 0
而 x[i] < 0xff：
average += x[i]
i += 1
average /= i
```
使用上述知识，请执行以下操作：

计算连续内存区域中连续的非零字节数，其中：

rdi = 第一个字节的内存地址  
rax = 连续非零字节数  
此外，如果 rdi = 0，则设置 rax = 0（我们将检查）！

举个测试用例的例子：
```
rdi = 0x1000
[0x1000] = 0x41
[0x1001] = 0x42
[0x1002] = 0x43
[0x1003] = 0x00
```
然后：应设置 rax = 3。

# 思路
这个算法我教育了ai半天，结果我自己做出来了...  
计算相邻字节的不为0的数，我们可以逐个字节进行cmp，为零即跳出，非零则继续循环

```
section .text
    global _start

_start:
    xor rax, rax    #清零rax    
    cmp rdi, 0    #rdi为0则跳过
    je set_zero    
    jmp loop    #开始循环

loop:
    mov dl, byte [rdi]    #赋值dl为rdi的byte大小数据
    test dl, dl    #是否为0
    je set_zero    
    inc rax    #递增1
    inc rdi    #递增1
    jmp loop    #重复

set_zero:
```
