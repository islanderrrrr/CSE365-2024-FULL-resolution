# 挑战简介
现在，我们将在每次运行之前动态地在内存中设置一些值。每次运行时，这些值都会改变。这意味着您需要对寄存器进行某种公式运算。我们会告诉您哪些寄存器是预先设置的，以及您应该将结果放在哪里。在大多数情况下，它是 rax。

在这一级别，您将使用控制流操作。这涉及使用指令间接和直接控制特殊寄存器 rip，即指令指针。您将使用 jmp、call、cmp 等指令及其替代指令来实现请求的行为。

之前，您学习了如何以伪控制方式操作数据，但 x86 为我们提供了直接操作控制流的实际指令。

有两种主要方式来操作控制流：

通过跳转  
通过调用  
在这一级别，您将使用跳转。

有两种类型的跳转：

无条件跳转  
有条件跳转  
无条件跳转始终触发，并且不基于先前指令的结果。

如您所知，内存位置可以存储数据和指令。您的代码将存储在 0x400042（每次运行时都会发生变化）。

对于所有跳转，都有三种类型：

相对跳转：跳转 + 或 - 下一条指令。

绝对跳转：跳转到特定地址。

间接跳转：跳转到寄存器中指定的内存地址。

在 x86 中，绝对跳转（跳转到特定地址）是通过首先将目标地址放入寄存器 reg 中，然后执行 jmp reg 来实现的。

在这一关，我们将要求您进行绝对跳转。执行以下操作：跳转到绝对地址 0x403000。

# 思路
**jump**:新的一个语法，用于实现跳转地址，语法等作用

**注意**:对于 x86 中的绝对跳转，您需要先将目标地址加载到寄存器中，然后使用该寄存器执行跳转。

```
section .text
global _start

_start:
    mov rax, 0x403000
    jmp rax
```
