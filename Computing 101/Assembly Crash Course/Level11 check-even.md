# 挑战简介
在此级别中，您将使用寄存器。您将被要求修改或读取寄存器。

我们将在每次运行之前动态设置内存中的一些值。每次运行时，这些值都会发生变化。这意味着您需要对寄存器执行某种类型的公式运算。我们会告诉您哪些寄存器是预先设置的，以及您应该将结果放在哪里。在大多数情况下，它是 rax。

在此级别中，您将使用位逻辑和操作。这将涉及大量直接与存储在寄存器或内存位置中的位交互。您还可能需要使用 x86 中的逻辑指令：and、or、not、xor。

仅使用以下指令：

and  
or  
xor  
实现以下逻辑：

如果 x 为偶数，则  
y = 1  
否则  
y = 0  
其中：  

x = rdi  
y = rax  

# 思路
通过了解x的奇偶属性，来赋给y值  
要求为上;

至于要怎么做，我们可以用到**异或xor**  
假想一下，你会发现一个规律:
对数xor后，假如**这个数是奇数，则结果会是偶数，相反一样**。
所以问题迎刃而解
```
section .text
    global _start

_start:
    xor rax, rdi
    and rax, 1    #rax, 1: 给rax赋值1或0
#and 操作将 rax 和 1 进行与运算，如果 rax 的 LSB 为 1（表示奇数），则结果将为 1；如果 LSB 为 0（表示偶数），则结果将为 0。
```
