# 挑战简介
```
GDB 是一个非常强大的动态分析工具，您可以使用它来了解程序在执行过程中的状态。您将在本模块中熟悉 gdb 的一些功能。

事实证明，gdb 可以完全控制目标进程。您不仅可以分析程序的状态，还可以修改它。虽然 gdb 可能不是对程序进行长期维护的最佳工具，但有时它可以快速修改目标进程的行为，以便更轻松地对其进行分析。

您可以使用 `set` 命令修改目标程序的状态。例如，您可以使用 `set $rdi = 0` 将 $rdi 清零。您可以使用 `set *((uint64_t *) $rsp) = 0x1234` 将堆栈上的第一个值设置为 0x1234。您可以使用
`set *((uint16_t *) 0x31337000) = 0x1337` 将 0x31337000 处的 2 个字节设置为 0x1337。

假设您的目标是某个联网应用程序，它从 fd 42 上的某个套接字读取。如果目标改为从 stdin 读取，也许对您的分析来说会更容易。您可以使用以下 gdb 脚本实现类似的功能：

start
catch syscall read
commands
silent
if ($rdi == 42)
set $rdi = 0
end
continue
end
continue

此示例 gdb 脚本演示了如何在系统调用时自动中断，以及如何在命令中使用条件来有条件地执行 gdb 命令。

在上一级别中，您的 gdb 脚本解决方案可能仍需要您复制和粘贴解决方案。这次，尝试编写一个脚本，它不需要你与程序对话，而是通过正确修改寄存器/内存来自动解决每个挑战。

程序收到信号 SIGTRAP、跟踪/断点陷阱。
```

# 思路
**还是那句话**,脚本可以写，但是操作太复杂了，这道题你应该是要提取50多次随机值，并输出,一下几点你要明白
- 如何获取rsp+0x32的储存值，我在discord看到的解答就是rax寄存器储存的就是随机值
- 既然知道rax是答案，你就又需要明白，如何在指定的位置输出这个rax的值
- 然后我不会了,我选择当人机

 答案是我输入50多次随机值得到的，求个大佬带我写脚本(哭)
